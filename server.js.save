const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const morgan = require('morgan');

// Charger variables d'environnement
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('combined'));

// Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100
});
app.use('/api/', limiter);

// Fichiers JSON
const ordersFile = path.join(__dirname, 'orders.json');
const usersFile = path.join(__dirname, 'users.json');

// Initialiser les fichiers
if (!fs.existsSync(ordersFile)) {
    fs.writeFileSync(ordersFile, JSON.stringify([]));
}

if (!fs.existsSync(usersFile)) {
    const salt = bcrypt.genSaltSync(10);
    const hash = bcrypt.hashSync(process.env.ADMIN_PASSWORD, salt);
    const defaultAdmin = [{
        id: 1,
        email: process.env.ADMIN_EMAIL,
        password: hash,
        role: 'admin',
        createdAt: new Date().toISOString()
    }];
    fs.writeFileSync(usersFile, JSON.stringify(defaultAdmin, null, 2));
}

// Fonctions utilitaires
function readOrders() {
    return JSON.parse(fs.readFileSync(ordersFile));
}

function writeOrders(orders) {
    fs.writeFileSync(ordersFile, JSON.stringify(orders, null, 2));
}

function readUsers() {
    return JSON.parse(fs.readFileSync(usersFile));
}

// Middleware auth
function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    
    if (!token) return res.status(401).json({ error: 'Token manquant' });

    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) return res.status(403).json({ error: 'Token invalide' });
        req.user = user;
        next();
    });
}

function isAdmin(req, res, next) {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'AccÃ¨s interdit' });
    }
    next();
}

// ========== ROUTES API ==========

// Login
app.post('/api/login', async (req, res) => {
    const { email, password } = req.body;
    
    const users = readUsers();
    const user = users.find(u => u.email === email);
    
    if (!user) {
        return res.status(401).json({ error: 'Email ou mot de passe incorrect' });
    }
    
    const valid = await bcrypt.compare(password, user.password);
    if (!valid) {
        return res.status(401).json({ error: 'Email ou mot de passe incorrect' });
    }
    
    const token = jwt.sign(
        { id: user.id, email: user.email, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: '24h' }
    );
    
    res.json({ token, user: { email: user.email, role: user.role } });
});

// CrÃ©er une commande
app.post('/api/order', async (req, res) => {
    try {
        const { pubgId, pseudo, pack, price, paymentMethod, reference } = req.body;

        // Validation
        if (!pubgId || !pseudo || !pack || !price || !paymentMethod || !reference) {
            return res.status(400).json({ error: 'Tous les champs sont requis' });
        }

        if (pubgId.length !== 11 || !/^\d+$/.test(pubgId)) {
            return res.status(400).json({ error: 'ID PUBG doit Ãªtre 11 chiffres' });
        }

        // CrÃ©er commande
        const order = {
            id: Date.now(),
            date: new Date().toISOString(),
            pubgId,
            pseudo,
            pack,
            price,
            paymentMethod,
            reference,
            status: 'en attente'
        };

        // Sauvegarder
        const orders = readOrders();
        orders.push(order);
        writeOrders(orders);

        res.status(201).json({ 
            message: 'Commande enregistrÃ©e', 
            orderId: order.id 
        });

    } catch (error) {
        console.error('Erreur:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// ADMIN: RÃ©cupÃ©rer toutes les commandes
app.get('/api/admin/orders', authenticateToken, isAdmin, (req, res) => {
    const orders = readOrders();
    res.json(orders);
});

// ADMIN: Mettre Ã  jour statut
app.put('/api/admin/orders/:id', authenticateToken, isAdmin, (req, res) => {
    const orderId = parseInt(req.params.id);
    const { status } = req.body;
    
    const orders = readOrders();
    const index = orders.findIndex(o => o.id === orderId);
    
    if (index === -1) {
        return res.status(404).json({ error: 'Commande non trouvÃ©e' });
    }
    
    orders[index].status = status;
    writeOrders(orders);
    
    res.json({ message: 'Statut mis Ã  jour' });
});

// ADMIN: Supprimer commande
app.delete('/api/admin/orders/:id', authenticateToken, isAdmin, (req, res) => {
    const orderId = parseInt(req.params.id);
    
    let orders = readOrders();
    orders = orders.filter(o => o.id !== orderId);
    writeOrders(orders);
    
    res.json({ message: 'Commande supprimÃ©e' });
});

// ADMIN: Statistiques
app.get('/api/admin/stats', authenticateToken, isAdmin, (req, res) => {
    const orders = readOrders();
    
    const totalOrders = orders.length;
    const totalRevenue = orders.reduce((sum, o) => {
        const price = parseInt(o.price.replace(/[^0-9]/g, '')) || 0;
        return sum + price;
    }, 0);
    
    const statusCount = {
        'en attente': orders.filter(o => o.status === 'en attente').length,
        'livrÃ©': orders.filter(o => o.status === 'livrÃ©').length,
        'annulÃ©': orders.filter(o => o.status === 'annulÃ©').length
    };
    
    res.json({
        totalOrders,
        totalRevenue,
        statusCount,
        lastOrders: orders.slice(-10).reverse()
    });
});



app.use('/admin', express.static(path.join(__dirname, 'admin')));

// DÃ©marrer le serveur
app.listen(PORT, () => {
    console.log(`âœ… Serveur dÃ©marrÃ© sur http://localhost:${PORT}`);
    console.log(`ğŸ“Š Admin: http://localhost:${PORT}/admin/admin.html`);
});
